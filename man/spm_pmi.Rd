% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{spm_pmi}
\alias{spm_pmi}
\title{(Positive) Pointwise mutual information.}
\usage{
spm_pmi(m_, rs_, cs_, ppmi = TRUE, ow = FALSE)
}
\arguments{
\item{m_}{A colun-oriented sparse matrix containing cooccurrence counts}

\item{ppmi}{A logical value indicating whether negative values should be truncated to 0 (i.e.
compute PPMI instead of PMI). TRUE by default.}

\item{ow}{A logical value indicating wether the result should be destructively copied over
the input matrix. FALSE by default.}
}
\value{
An (column-stored sparse) matrix, isomorphic to m_ with the (P)PMI values for m_.
        If ow == TRUE, m_ is replaced with this value.
}
\description{
Compute a (P)PMI matrix from raw frequency counts, stored as a column-oriented sparse matrix.
}
\details{
The PMI value for each cell is equal to log( p(i,j) / p(i)p(j) ), i.e. the log of the observed
probability over the expected probability.

The PPMI variant adds 1 to this value in order to truncate all values to 0 and maintain
sparsity.

WARNING: In order to prevent a memory explosion, zero-values in the input matrix are never
calculated, which has the numerical side-effect of replacing all -Inf values with zero entries
in the non-truncated output matrix. This is a temporary solution.
}
