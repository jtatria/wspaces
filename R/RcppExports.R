# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Load sparse matrices from disk.
#'
#' Reads a sparse matrix from binary file containing a sequence of (long, long, double) triplets.
#'
#' This function uses a memory mapped file to read the given binary file as an array of triplets
#' containing the coordinates and values for non-zero entries in a sparse matrix. This format is
#' compatible with the binary format used natively by Glove. The component values in the triplets
#' are used to construct the i, j and x vectors needed by Matrix::sparseMatrix.
#'
#' @param file A character vector indicating the path to the file to be read.
#'
#' @return A Matrix::sparseMatrix built from the triplets read from the given binary file.
#'
#' @importClassesFrom Matrix dgTMatrix
load_spm <- function(file) {
    .Call('wspaces_load_spm', PACKAGE = 'wspaces', file)
}

#' (Positive) Pointwise mutual information.
#'
#' Compute a (P)PMI matrix from raw frequency counts, stored as a column-oriented sparse matrix.
#'
#' The PMI value for each cell is equal to log( p(i,j) / p(i)p(j) ), i.e. the log of the observed
#' probability over the expected probability.
#'
#' The PPMI variant adds 1 to this value in order to truncate all values to 0 and maintain
#' sparsity.
#'
#' WARNING: In order to prevent a memory explosion, zero-values in the input matrix are never
#' calculated, which has the numerical side-effect of replacing all -Inf values with zero entries
#' in the non-truncated output matrix. This is a temporary solution.
#'
#' @param m_    A colun-oriented sparse matrix containing cooccurrence counts
#' @param ppmi  A logical value indicating whether negative values should be truncated to 0 (i.e.
#'              compute PPMI instead of PMI). TRUE by default.
#' @param ow    A logical value indicating wether the result should be destructively copied over
#'              the input matrix. FALSE by default.
#'
#' @return An (column-stored sparse) matrix, isomorphic to m_ with the (P)PMI values for m_.
#'         If ow == TRUE, m_ is replaced with this value.
spm_pmi <- function(m_, rs_, cs_, ppmi = TRUE, ow = FALSE) {
    .Call('wspaces_spm_pmi', PACKAGE = 'wspaces', m_, rs_, cs_, ppmi, ow)
}

#' TF-IDF weighting.
#'
#' Weigth the given frequency matrix using the TF-IDF stategy.
#'
#' TF-IDF weights attempt to moderate the effect of very common terms, by dividing the total
#' frequency of a term within a context (i.e. a document, but in general any corpus segment),
#' by the number of contexts in which the term appears.
#'
#' The idea behind this approach is that terms that appear in every possible context do not
#' provide any additional information to the contexts in which they appear. Hence, all TF-IDF
#' strategies compute weights as some variation of \eqn{TF_{t,c} / IDF_{t}}, where
#' \eqn{TF_{t,c}} is a monotonic function of a term t's prevalence within a specific context
#' c and \eqn{IDF_{t}} is an inversely monotonic function of the term t's prevalence in all
#' contexts across the entire corpus.
#'
#' Note that the TF term is valid for a term in a context, while the IDF term is valid for a
#' term across the entire corpus.
#'
#' Values of tf_mode and idf_mode indicate how the TF and IDF terms are computed, as indicated
#' below.
#'
#' \itemize{
#'   \item{TF modes}
#'   \itemize{
#'     \item{0: Boolean: 1 if tf > 0; 0 otherwise.}
#'     \item{1: Raw: Raw term frequency.}
#'     \item{2: Normalized: (default) Term frequency divided by the total number of terms
#'              in document (the 'length').}
#'     \item{3: Log-normlized: Natural log of the term frequency over total document
#'              terms, + 1.}
#'     \item{4: 0.5 normalized: K*(1-K) * (tf / max( tf ) ), with K set to 0.5.}
#'   }
#'   \item{IDF modes}
#'   \itemize{
#'     \item{0: Unary: 1 if df > 0, but terms with 0 DF are by definition excluded of the
#'              lexicon, so 1.}
#'     \item{1: Plain: log of total number of documents, D, over the term's df.}
#'     \item{2: Smooth: (default) log of total number of documents, D, over the term's df,
#'              plus 1.}
#'     \item{3: Max: log of maximum df, over the term's df.}
#'     \item{4: Probabilistic: log of the total number of documents minus the term's df
#'              over the term's df.}
#'   }
#' }
#'
#' @param tf_       A matrix with one row for each term, and as many columns as documents or corpus
#'                  segments there are frequencies for.
#' @param df_       A vector of length equal the number of rows in tf_, containing document
#'                  frequencies, to compute the IDF component.
#' @param tf_mode   A term frequency weigthing strategy. See details.
#' @param idf_mode  An inverse document frequency weigthing strategy. See details.
#' @param ow        A logical vector indicating whether the result should be destructively copied
#'                  over the input matrix.
#'
#' @return An isomorphic matrix to tf_, with entries weighted by the given strategy. If ow == TRUE,
#'        tf_ is replaced with this value.
weight_tfidf <- function(tf_, df_, tf_mode = 2L, idf_mode = 2L, ow = FALSE) {
    .Call('wspaces_weight_tfidf', PACKAGE = 'wspaces', tf_, df_, tf_mode, idf_mode, ow)
}

idf <- function(dfs_, D, mode = 2L) {
    .Call('wspaces_idf', PACKAGE = 'wspaces', dfs_, D, mode)
}

tf <- function(tfs_, L, mode = 2L) {
    .Call('wspaces_tf', PACKAGE = 'wspaces', tfs_, L, mode)
}

#' Cosine distances.
#'
#' Compute the cosine distance between the given vectors. The cosine distance between vectors
#' i and j is equal to the dot product between them divided by the product of their norms:
#' \eqn{ ( i \dot j ) / [[i]]*[[j]] }.
#'
#' The given matrix will be interpreted as an array of column vectors for which cosine distances
#' will be computed. If transpose == TRUE, the matrix will be interpreted as an array of row
#' vectors. In any case, the resulting matrix will be square, symmetric, and with dimensions
#' equal to the number of (column or row) vectors.
#'
#'
#' @param m_        A matrix of column (or row) vectors for which to compute distances.
#' @param transpose A logical vector indicating if distances should be computed across row vectors.
#'                  False by default.
#'
#' @return A square symmetric matrix of dimension equal to the column (or row) dimension of the
#'         given input matrix of cosine distances between the column (or row) vectors in the input
#'         matrix.
vector_cosine <- function(m_, transpose = FALSE) {
    .Call('wspaces_vector_cosine', PACKAGE = 'wspaces', m_, transpose)
}

